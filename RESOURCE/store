#!/bin/bash

if [ $# -eq 1 ] && [ $1 == 'help' ]; then
#分支：“store help”
    echo -e "功能：使用这个命令将文件打包并且复制到目标路径。\n" \ 
    "\n" \
    "store [target] [directory]：将目标储存到目录当中。"
fi

if [ $# -eq 2 ]; then
#分支：“store [target] [directory]”
    
    #第一个参数是要打包的文件夹
    directory=$1
    #第二个参数是移动到目录
    targ_dir=$2
    
    #根据当前时间生成最终目标
    time=`date +"%Y%m%d"`
    final_targ="${targ_dir}/${time}"
    #调整最终目标
    count=0
    while [ -d $final_targ ]
    do
        let "count=count+1"
        if [ count -eq 1 ]; then
            final_targ="${final_targ}.${count}"
        else
            final_targ="${final_targ%.*}.${count}"
        fi
    done
    echo "目标文件夹：${final_targ}"
    mkdir $final_targ
    
    #遍历并打包
    
	folders=()
	
	#@GPT4：请注意，当使用管道与 while 循环结合时
	#整个循环会在一个子shell中执行。
	#这意味着在循环内部设置的任何变量都不会影响到循环外部的环境。
	#如果你需要在循环外部访问在循环内部设置的变量，
	#你可能需要考虑使用其他方法来传递这些变量，
	#例如使用文件、命名管道、或者将输出重定向到一个临时文件，
	#然后在循环外部读取这个文件。
	
	find "$directory" -maxdepth 1 -type d | while IFS= read -r folder; do
    #遍历目标，深度1,目录类型 | 定义字段分割符默认情况 逐行读取管道内容并保存到 folder变量中

		if [[ "$folder" != "$directory" && "$folder" != "$directory"/.. ]]; then
        #不是特殊文件夹

			if [ -d $folder ]; then
			#文件夹存在
			
				echo $folder
				name=`basename $folder`
				target="${final_targ}/${name}.tar.gz"
				tar -zcvf "$target" "$folder"

			fi
			
		fi
		
		
	done
	
fi	
